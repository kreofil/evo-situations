#ifndef __pp_vector__
#define __pp_vector__
// pp-vector.h
// Объявление обобщенного вектора, состоящего из идентичных аргументов,
// которые являются основами специализаций.
// В данном случае речь не идет об обработке альтернатив.
// Поэтому обобщенные функции используются только в случае
// расширения функциональности

#include <stdint.h>
#include <stdio.h>

//==============================================================================
// Структура обобщенного вектора
//==============================================================================
typedef struct ppVector {
  uint32_t  foundation_size;  // размер основы специализации
  void*     foundation_addr;  // адрес основы специализации
  uint32_t  size;             // текущий размер вектора (сколько элементов)
  uint32_t  capacity;         // текущая вместимость (выделенных элементов)
  void*     vec_memory;       // указатель на память, выделяемую вектору
}<> ppVector;

//==============================================================================
// Интерфейс вектора, используемый при программировании
//==============================================================================

// Начальная инициализация вектора
void ppVector_init(ppVector* v);

// Определение текущего размера вектора
uint32_t ppVector_size(ppVector* v);

// Определение текущей вместимости
uint32_t ppVector_capacity(ppVector* v);

// Резервирование памяти под заданное количество элементов
void ppVector_reserve(ppVector* v, uint32_t new_cap);

// Изменение числа элементов в векторе (size)
// Новые элементы не устанавливаются или вектор обрезается
void ppVector_resize(ppVector* v, uint32_t new_size);

// Освободение памяти до размера size
void ppVector_shrink_to_fit(ppVector* v);

// Занесение в хвост вектора значения, размещенного
// в специализированной переменной.
// Предварительно значение должно быть занесено в специализацию
void ppVector_push_back(ppVector* v);

// Неконтролируемый доступ к элементу вектора по индексу.
// Элемент из вектора переносится в основу специализации.
// Оттуда его можно будет забрать, используя знание типа вектора, присваиванием.
void ppVector_index(ppVector* v, uint32_t index);

// Фиксация в основе специализации значения первого элемента вектора
void ppVector_front(ppVector* v);

// Фиксация в основе специализации значения последнего элемента вектора
void ppVector_back(ppVector* v);

// Возврат указателя на текущий вектор элементов в динамической памяти
void* ppVector_data(ppVector* v);

// Вставка осуществляется по целочисленному индексу. Без итераторов
void ppVector_insert_index(ppVector* v, uint32_t index);

// Удаление последнего элемента вектора
void ppVector_pop_back(ppVector* v);

// Удаление из вектора от одного до нескольких элементов
void ppVector_erase(ppVector* v, uint32_t first, uint32_t last);

// Очистка вектора от данных без изменения вместимости
void ppVector_clear(ppVector* v);

// Удаление у вектора динамчески выделенной памяти.
// Переход в начальное состояние
void ppVector_destroy(ppVector* v);

// Обмен содержимым между двумя однотипными векторами
void ppVector_swap(ppVector* v1, ppVector* v2);

// Пересылка данных из одного вектора в другой. Векторы однотипные
void ppVector_move(ppVector* dest, ppVector* src);

// Копирование данных из одного вектора в другой. Векторы однотипные
void ppVector_copy(ppVector* dest, ppVector* src);

//==============================================================================
// Вспомогательные и дополнительные функции для работы с ПП векторами
// Возможно уйдут в отдельный заголовочный файл и другие библиотеки
//==============================================================================

// Обобщающая функция вывода элемента вектора в поток.
// Переопределяется для каждой специализации для вывода конкретного значения
void ppVector_element_print<ppVector* v>(FILE* f);

// Функция, осуществляющая вывод всех элементов вектора в цикле.
// Использует полиморфную функцию вывода отдельного элемента
void ppVector_print(FILE* f, ppVector* v);

//==============================================================================
// Препроцессорные определения, служащие оберткой, расширяющей функциональность.
//==============================================================================

//------------------------------------------------------------------------------
// Макроопределение, используемое для формирования специализации по шаблону
// Скрывает дополнительные манипуляции, связанные с установкой
// внутренних параметров
#define ppVector_VAR(foundation_type, vector_name)      \
  struct ppVector.foundation_type vector_name;          \
  vector_name.foundation_size = sizeof(vector_name.@);  \
  vector_name.foundation_addr = &(vector_name.@);       \
  vector_name.size = 0;                                 \
  vector_name.capacity = 0;                             \
  vector_name.vec_memory = NULL;
  // struct ppVector.foundation_type vector_name =
    // {sizeof(vector_name.@), &(vector_name.@),0,0};

//------------------------------------------------------------------------------
// Макрос, используемый для занесения значения в хвост вектора.
// Обертывает функцию ppVector_push_back и предварительное присваивание
// пересылаемого значения внутренней переменной
#define ppVector_PUSH_BACK(vector_name, value) \
  vector_name.@ = (value); ppVector_push_back((ppVector*)&vector_name);

//------------------------------------------------------------------------------
// Макрос, используемый для чтения элемента из вектора в заданную переменну.
// Обертывает функцию ppVector_index и присваивание внутренней переменной
// указанной внешней переменной
#define ppVector_GET_VAL_INDEX(destination, vector_name, index) \
  ppVector_index((ppVector*)&vector_name, (index)); destination = vector_name.@;

//------------------------------------------------------------------------------
// Макрос для занесения первого элемента вектора в указанную переменную
#define ppVector_GET_FRONT_VAL(destination, vector_name) \
  ppVector_front((ppVector*)&vector_name); destination = vector_name.@;

//------------------------------------------------------------------------------
// Макрос для занесения последнего элемента вектора в указанную переменную
#define ppVector_GET_BACK_VAL(destination, vector_name) \
  ppVector_back((ppVector*)&vector_name); destination = vector_name.@;

#endif // __pp_vector__
