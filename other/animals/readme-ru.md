# Программа про животных

Реализовать с использованием разных парадигм задачу про животных. Исходную постановку в дальнейшим попытаться развить по разным направлениям. Посмотреть, каким образом каждая из парадим будет поддерживать эволюционное расширение и гибкость разработки программы.

## Начало

Будем считать, что уже написано. Имеются следующие животные и их функционал:

- Животные
    - Слон
        - Ходит "Топ-топ"
        - Издает звуки "Ду-ду"
    - Собака
        - Ходит "Чап-чап"
        - Издает звуки "Гав-гав"
    - Пингвин
        - Ходит непонятно как (по умолчанию)
        - Издает звуки "Линукс рулит"
        - Плавает "Буль буль" (каждый, кто плавает, делает это уникально)
    - Червяк
        - Ходит "Ползает"

## Реализации

1. ООП с использованием интерфейсов, как это предлагают другие "эксперты" ([Большие проблемы наследования в ООП](https://www.youtube.com/watch?v=-n6784KeQMs)). Получаются интерфейсы в основном от одной функции.
2. Процедурный подход с заданием альтернатив в специальных классифицирующих структурах. Предварительно можно посмотреть, как иерархическое описание животных отобразится на реляционную модель данных, когда встроенную логику заменим на отношение между сущностями и различными категориями.
3. ООП, имитирующий процедурное решение.
4. ППП построенное естественно процедурной схеме.
5. А может есть какой-то свой вариант решения? Самый "крутой". Желающие могут написать свою альтернативу уже существующим решениям. Желательно на C++ или C, или PPC. Но можно, ради хохмы и научного интереса реализовать на другом языке (тогда придется с ним "мучиться" и для вариантов дальнейшего развития программы).

## Варианты развития программы

Можно просто попытаться прогнать по простейшим эволюционным расширениям, но для данного примера интереснее рассмотреть содержательные варианты.

В результате можно оценить, какие изменения будут происходить с ранее написанным кодом для каждого из вариантов решения. Также можно будет рассмотреть возможность эволюционного расширения.

Ниже представлены варианты. Возможно их порядок может меняться. Или в ряде случаев можно каждый раз стартовать от исходных решений. Но предполагаю, что мое решение будет идти по нарастающей. 

Возможно, что свое решение я демонстрировать не буду, а предоставлю в качестве упражнений. Или покажу только некоторые варианты.

### Мы забыли, что собака может плавать
В результате предлагается сформировать для собаки функционал, обеспечивающий поддержку плавания по собачьи для каждого из рассматриваемых вариантов кода.

### Мы вдруг вспомнили, что пингвин может еще и нырять
Возникают вопросы:

- Куда определить ныряние? Стоит ли включать его в другой интерфейс или создать новый (не все ныряют)?
- Как оно будет интегрироваться с другой функциональностью?

### Расширение общего интерфейса еще одной альтернативной функциональностью.
Можно, например, рассмотреть вариант, когда каждое из животных обладает таким свойством как поедание определенной пищи. Оно есть у всех и определяется уникально для каждого (не делать обработчик по умолчанию).

### Добавление такой общей функциональности, как принадлежность к классу животных
Отношение к млекопитающим, птицам и прочим - это общее свойство. Но оно повторяется. Притом для разных животных. Разделение на отдельные категории вряд ли рационально. Поэтому интересна реализация как подмножество категорий животного.

### Мультиметод или множественный полиморфизм
Хотя бы для двух альтернатив. Но можно еще добавить и три, так как пример достаточно неформальный. Для каждого варианта отношений придумать свой функционал. Это просто, достаточно выводить какую-то нестандартную фразу для каждой из комбинации животных. Например:
 - Слон - собака. А он себе идет и лаю твоег не замечает.
 - Собака - слон. Ай Моська, знать она сильна, что лает на слона.

### Добавление нового животного
Можно добавить, например, рыбу, орла и т.д. С появлением орла появится необходимость ввода функционала полета. Ну а далее может быть муха и прочие. Можно разделить это добавление как разные ветви развития программы. Но можно и двигаться в любом порядке, интегрируя воедино добавляемые варианты...
