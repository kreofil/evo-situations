// Пример диспетчеризации с двумя аргументами и двумя альтернативами

// Примечание. Количество альтернатив на производительность ОО диспетчеризации
// не должно влиять, так как обращение к виртуальным методам осуществляется одинаково

// Базовый класс, определяющий обобщение
class d0 {
public:
    // Виртуальные методы, задающие формирование обработчиков
    // В принципе достаточно только их, если они не чистые
    virtual void mm(d0* x);    // запуск мультиметода для двух аргументов
    virtual void d0d1(); // Первый - это d0, второй - d1
    virtual void d1d0(); // Первый - это d1, второй - d0
};

void d0::mm(d0* x) { x->d0d1(); }
void d0::d0d1() {/*нужна нагрузка?*/}
void d0::d1d0() {/*нужна нагрузка?*/}

// Экземпляр d0
d0 x0;

// Производный класс 1, задающий альтернативу
class d1 {
public:
    void mm(d0* x);    // запуск мультиметода для двух аргументов
    // virtual void d0d1(); // Первый - это d0, второй - d1
    // virtual void d1d0(); // Первый - это d1, второй - d0
};

void d1::mm(d0* x) { x->d1d0(); }
// void d0d1() {/*нужна нагрузка?*/}
// void d1d0() {/*нужна нагрузка?*/}

// Экземпляр d1
d0 x1;

// функция для удобства генерации общего тестового каркаса
// Можно и без нее
inline void mm(d0* x0, d0* x1) {x0->mm(x1);}


// Это для проверки работоспособности. На самом деле может замениться на вызов из теста
int main() {
    mm(&x0, &x0);
    mm(&x0, &x1);
    mm(&x1, &x0);
    mm(&x1, &x1);
    return 0;
}
