//==============================================================================
// word32.c - содержит реализации бестиповых функций для 32-разрядного слова
//==============================================================================

#include "word32.h"

//==============================================================================
// Функции, осуществляющие бестиповые вычисления
//==============================================================================

// Установка признака специализации для обобщения (равен 0)
void SetTag_w32(w32* opd) {
  // init_spec(w32.void, opd);
}
// Установка имени в обобщенное 32-х разрядное слово
void SetName_w32(w32* opd, char* name) {
  opd->name = name;
}
// Установка значения в обобщенное 32-х разрядное слово
void SetVal_w32(w32* opd, unsigned val) {
  opd->val = val;
}
// Одновременная установка имени и значения в 32-х разрядное слово
void Set_w32(w32* opd, char* name, unsigned val) {
  SetTag_w32(opd);
  SetName_w32(opd, name);
  SetVal_w32(opd, val);
}

// Бестиповое целочисленное 32-х разрядное сложение со знаком и без знака
// Обе слились, так как выполняются идентично на уровне архитектуры
void Add_w32(w32* src1, w32* src2, w32* dst) {
  dst->val = src1->val + src2->val;
}

// Вывод бестипового слова в консоль (для тестового отображения)
void DebugOut_w32(w32* opd) {
  printf("w32: 0x%x\n", opd->val);
}

// Генерация ассемблерного кода для бестипового целочисленного сложения
// 32-разрящных целых чисел. Идентично для знаковых и беззнаковых
// Реализация для операндов во внешней памяти без оптимизации
void GenRiskV_Add_w32(w32* src1, w32* src2, w32* dst) {
  // Формирование регистров следует сделать с автоматической подстановкой
  // Из доступного пула регистров!!!! Нужна функция!!!
  printf("  la  t0, %s\n", src1->name);     // Загрузка адреса 1-го операнда
  printf("  la  t1, %s\n", src2->name);     // Загрузка адреса 2-го операнда
  printf("  la  t2, %s", src2->name);       // Загрузка адреса 2-го операнда
  printf("  lw  t0, (t0)\n");               // Загрузка 1-го операнда
  printf("  lw  t1, (t1)\n");               // Загрузка 2-го операнда
  printf("  add t0, t0, t1\n");             // Сложение операндов
  printf("  sw  t0, (t2)\n");               // Запись результата в память
}

