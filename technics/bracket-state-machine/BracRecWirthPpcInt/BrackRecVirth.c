//
// BrackRecVirth.c - рекурсивный распознаватель вложенности круглых скобок.
// Построен на основе диаграмм Вирта, эквивалентных следующей РБНФ
//
// $S = {/ "(" [ S ] ")" /}.
//

// Используется целочисленный фиксатор для выхода из цикла
// по отрицательному значению без фиксации состояний ошибки и
// успешного завершения
#include <stdio.h>
#include <string.h>

_Bool S();
_Bool Z();

char str[256];  // Строка с входной цепочкой, имитирующая входную ленту
// string str; // Строка с входной цепочкой, имитирующая входную ленту
int i;          // Текущее положение входной головки
int erFlag;     // Флаг, фиксирующий наличие ошибок в середине правила

// Функция, реализующая чтение символов в буфер из входного потока.
// Используется для ввода с клавиатуры распознаваемой строки.
// Ввод осуществляется до нажатия на клавишу Enter.
// Символ '\n' является концевым маркером входной строки.
void GetOneLine(FILE *is, char* str) {
  str[0] = '\0';
  size_t n = 256;
  ssize_t len = getline(&str, &n, is);
}

//==============================================================================
// Описание автомата S, распознающего вложенность скобок
//==============================================================================

//------------------------------------------------------------------------------
// Обобщение, определяющее состояния автомата S
typedef struct StateS{}<Start, S1, S2, S3: void;>StateS;

//------------------------------------------------------------------------------
// Обобщенная функция и обработчики, реализующие состояния автомата S

int CalcStateS<StateS* state>() {
  printf("Base state of S machine is impossible!\n");
  return 0;
};

int CalcStateS<StateS.Start* s>() {
//_0: // Начало диаграммы
  if(str[i] == '(') {
    i++;
    init_spec(StateS.S1, s);
    return -1;
  }
  return 0; // Первый символ цепочки некорректен
            // что это ошибка, лучше определить снаружи
};

int CalcStateS<StateS.S1* s>() {
// _1: // Точка 1 диаграммы
  if(str[i] == ')') {
    i++;
    init_spec(StateS.S3, s);
    return -1;
  }
  if(S()) {
    init_spec(StateS.S2, s);
    return -1;
  }
  erFlag++;
  printf(
    "Position %d, Error 1: I want closed bracket or next opened bracket!\n", i);
  // init_spec(StateS.False, s);
  return 0;
}

int CalcStateS<StateS.S2* s>() {
// _2: // Точка 2 диаграммы
  if(str[i] == ')') {
    i++;
    init_spec(StateS.S3, s);
    return -1;
  }
  erFlag++;
  printf("Position %d, Error 2: I want closed bracket!\n", i);
  // init_spec(StateS.False, s);
  return 0;
}

int CalcStateS<StateS.S3* s>() {
// _3: // Точка 3 диаграммы
  if(str[i] == '(') {
    i++;
    init_spec(StateS.S1, s);
    return -1;
  }
  // init_spec(StateS.True, s);
  return 1;
}

//------------------------------------------------------------------------------
// Автомат, реализующий распознавание нетерминала S.
_Bool S() {
  struct StateS state;
  init_spec(StateS.Start, &state);
  int out = -1;
  while(out == -1) {
    out = CalcStateS<&state>();
  }
  return out;
}

//==============================================================================
// Описание автомата Z, запускающий распознаватель
//==============================================================================


//------------------------------------------------------------------------------
// Обобщение, определяющее состояния автомата Z
typedef struct StateZ{}<Start, S1: void;>StateZ;

//------------------------------------------------------------------------------
// Обобщенная функция и обработчики, реализующие состояния автомата Z

int CalcStateZ<StateZ* state>() {
  printf("Base state of Z machine is impossible!\n");
  return 0;
};

int CalcStateZ<StateZ.Start* state>() {
//_0: // Начало диаграммы
  if(S()) {
    init_spec(StateZ.S1, state);
    return -1;
  }
  return 0; // Первый символ цепочки некорректен
            // что это ошибка, лучше определить снаружи
};

int CalcStateZ<StateZ.S1* state>() {
// _1: // Точка 1 диаграммы
    // За последней скобкой должен быть "конец строки"
  if(str[i] == '\n') {
    return 1;
  }
  erFlag++;
  printf("Position %d, Error 3: I want end of line!\n", i);
  return 0;
}

//------------------------------------------------------------------------------
// Автомат, реализующий распознавание нетерминала Z.
_Bool Z() {
  struct StateZ state;
  init_spec(StateZ.Start, &state);
  int out = -1;
  while(out == -1) {
    out = CalcStateZ<&state>();
  }
  return out;
}

//==============================================================================
// Функция запускающая разбор и определяющая корректность его завершения,
// если первый символ не принадлежит цепочки
_Bool Parser() {
  // Начальная инициализация.
  erFlag = 0;
  i = 0;

  // Процесс пошел!
  if(Z()) {
    return 1; // Все прошло нормально
  } else {
    if(erFlag) {
      printf("Position %d , Error 4: Internal Error!\n", i);
    } else {
      printf("Position %d, Error 5: Incorrect first symbol of S!\n", i);
    }
    return 0; // Есть ошибки
  }
}

//==============================================================================
// Главная функция используется для тестирования до тех пор,
// пока не будет прочитана пустая строка
int main () {
  char strCursor[256];
  str[0] = '\0';
  // Цикл распознавания различных входных цепочек
  // do {
  // while(str[0] != '\n') {
  while(1) {
    // Чтение очередной входной цепочки в буфер
    printf("Input bracket\'s expression!: ");

    // Формируем очередную строку скобок для распознавания.
    GetOneLine(stdin, str);
    if(str[0] == '\n') {
      break;
    }

    // Здесь начинается разбор принятой строки.
    if(Parser()) {
      printf("+++++ OK! +++++\n");
    } else {
      printf("----- Fatal error (look upper error message)! -----\n");
    }

    // Вывод разобранной строки и значения позиции входой головки.
    printf("Line: %s", str);
    printf(" Pos: ");
    for(int j = 0; j < i; ++j) {
      printf("%c", '-');
    }
    printf("^  i = %d\n\n", i);

  }
  // } while(str[0] != '\n');
  printf("Goodbye!\n");
  return 0;
}

